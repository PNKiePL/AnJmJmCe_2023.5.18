#pragma once
#ifndef 数字格式_H 
#define 数字格式_H

#include<E:\lib\头文件 c++.h>
#include<E:\lib\cmd.h>

//>数字每N位分隔 \ vector<类型>
template<typename 类型, int N>
class 数N分 ///2023年6月3日
{
public:
	类型 N位个数 = 0, N位个数_有数值 = 1, _2N位个数 = 0, N位数个数, _2N位数个数; //>N位个数= >已进位的N位数个体 \ N位个数_有数值= 有数值的N位数个体 \ N位个数_有数值= N位个数+1;
	vector<类型>计数; //>[0] 不用, 从[1]开始
	int 十 = 10, 一百 = 100, 一千 = 1000, 一万 = 10000, 十万 = 100000, 百万 = 1000000, 千万 = 10000000, 一亿 = 100000000;
	int 序号_第一个n = 1;
public:
	数N分() //并不会 每次用函数前都运行
	{
		cout << "Class开始";
		cout << '\n';
		计数.assign(2, 0);
		初始化();
	}
public:
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//初始化
	auto 初始化() {
		N位个数_有数值 = 1;
		N位个数 = 0;
	}

	auto N位个数初始化(vector<类型>& vec) //标记 有数值的
	{
		for (size_t i = 1; i < 14; i++)
		{
			if (i < vec.size()) //vec[i]有数值
			{
				if (vec[i] > 0) {
					N位个数_有数值 = i;
				}
			}
		}
		N位个数 = N位个数_有数值 - 1; //一般用这个, 不用 N位个数_有数值
	}
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//功能
	auto 整数位数(类型 uu) //?不行
	{
		int 位数 = 1;
		while (uu >= 10)
		{
			uu /= 10;
			位数 += 1;
		}
		///cout <<"uu= " << uu;
		///cout << ", 位数= " << 位数;
		///cout << '\n';
		return 位数;
	}
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//零件
	//>零件 \ cout \ cout到cmd
	auto 补充0(vector<类型>& vec, 类型 N位数序号) //>如果是n位数, 显示N-n个0
	{
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		//>左边有数字, 中间+0
		类型 N位数序号位置上的位数n = 整数位数(vec[N位数序号]); //to_string(vec[N位数序号]).size();
		//左边的N位数有数字, 才需要+0
		if (N位个数 >= N位数序号
			&& N位数序号 < vec.size()) //&& (N位数序号位置上的位数n >= 0)
		{
			类型 _0的个数 = N - N位数序号位置上的位数n;
			///cout << "_0的个数= " << _0的个数;
			///cout << '\n';
			if (_0的个数 >= 0
				&& _0的个数 <= N) { //case(负数): 会一直循环 
				//输出'0'
				for (size_t i = 0; i < _0的个数; i++) {
					///cout << "N位数序号= " << N位数序号;
					///cout << '\n';
					cout << "0";
				}
			}
		}
		vecdatap = nullptr; vecp = nullptr;
	}

	auto 进位(vector<类型>& vec, 类型 N位数序号)
	{
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		//超过N位数-->进位
		// >if vec[n]有数值-->
		if (N位数序号 <= N位个数_有数值) //N位个数_有数值< vec.size \ size位置不一定用过, 会一直pushback
			///if (N位数序号 < vec.size()) 
		{
			//> if N位数序号< size-->进位 / = size-->push_back(0)
			if (N位数序号 + 1 == vec.size()) //对应n, n+1
			{
				///cout << N位数序号 + 1 << "位置增加0 "; //N位数序号= n= 序号
				///cout << '\n';
				//vec.resize(N位个数_有数值 + 3, 0);
				vec.push_back(0); //新增一个序号
			}
			//>if N位数序号> size-->N位置没内容-->忽略
			if (N位数序号 < vec.size())
			{
				//>if vec[n]多于 N位数-->进位
				int 大于后进位 = 0;
				switch (N)
				{
				default:
					大于后进位 = 1;
					//N位数的 最大值+1
					for (size_t i = 0; i < N; i++)
					{
						大于后进位 *= 10;
					}
					break;
				case(1):
					大于后进位 = 十;
					break;
				case(2):
					大于后进位 = 一百;
					break;
				case(3):
					大于后进位 = 一千;
					break;
				case(4):
					大于后进位 = 一万;
					break;
				case(5):
					大于后进位 = 十万;
					break;
				case(6):
					大于后进位 = 百万;
					break;
				case(7):
					大于后进位 = 千万;
					break;
				case(8):
					大于后进位 = 一亿;
					break;
				}
				//>if vec[n]多于 N位数-->进位
				if (vec[N位数序号] >= 大于后进位) {
					//更新 N位个数
					if (N位个数 <= N位数序号 - 1) { //限定 \ 只运行一次
						N位个数 = N位数序号; //记录位数
						N位个数_有数值 = N位数序号 + 1;
					}
					while (vec[N位数序号] >= 大于后进位) //>限制在N位数 \ 超过N位数就进位
					{
						vec[N位数序号] = vec[N位数序号] - 大于后进位;
						/// 2023年6月10日 15:00
						//? 这句怎么没啦?
						vec[N位数序号 + 1] += 1;
						///cout << "n位置是 " << vec[N位数序号]; //n是序号
						///cout << '\n';
						///cout << "左边是 " << vec[N位数序号 + 1];
						///cout << '\n';
					}
				}
			}
		}
		vecdatap = nullptr; vecp = nullptr;
	}

	//coutN位数 \ 只读取
	auto 返回N位数(vector<类型>& vec, 类型 N位数序号) //>N位数= N位数的内容 \ N位个数= 有几个N位数
	{
		if (N位个数_有数值 >= N位数序号) {
			cout << vec[N位数序号] << ",";
		}
	}
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
   //>零件 \ 输出str
	string 补充0(string 结果, vector<类型>& vec, 类型 N位数序号) //>如果是n位数, 显示N-n个0
	{
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		//>左边有数字, 中间+0
		类型 N位数序号位置上的位数n = 整数位数(vec[N位数序号]);
		//左边的N位数有数字, 才需要+0
		if (N位个数 >= N位数序号
			&& N位数序号 < vec.size())
		{
			类型 _0的个数 = N - N位数序号位置上的位数n;
			if (_0的个数 >= 0
				&& _0的个数 <= N) { //case(负数): 会一直循环 
				//输出'0'
				for (size_t i = 0; i < _0的个数; i++) {
					结果.append("0");
				}
			}
		}
		vecdatap = nullptr; vecp = nullptr;
		return 结果;
	}
	string 返回N位数(string 结果, vector<类型>& vec, 类型 N位数序号) //>N位数= N位数的内容 \ N位个数= 有几个N位数
	{
		if (N位个数_有数值 >= N位数序号) {
			结果.append(to_string(vec[N位数序号])); 结果.append(",");
		}
		return 结果;
	}
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//>零件 \ vec的数N分
	auto 进位再cout(vector<类型>& vec)
	{
		//!进位	从右往左 
		//!显示	从左往右 \ 是否有数字->补充0->显示数字->右边的N位数 
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		N位个数初始化(vec);
		序号_第一个n = 1;
		//x..............................................................................
		//>进位	从小往大
		for (size_t i = 序号_第一个n; i < 14; i++)
		{
			进位(vec, i);
		}
		//x..............................................................................
		//>显示	从大往小 \ 是否有数字->补充0->显示数字->右边的N位数 
		for (size_t i = N位个数_有数值; i > 序号_第一个n; i--)
		{
			补充0(vec, i);
			返回N位数(vec, i); //cout","
		}
		补充0(vec, 1);
		cout << vec[1];
		vecdatap = nullptr; vecp = nullptr;
	}

	auto 进位再返回str(string& 结果str, vector<类型>& vec)
	{
		//!进位	从右往左 
		//!显示	从左往右 \ 是否有数字->补充0->显示数字->右边的N位数 
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		N位个数初始化(vec);
		序号_第一个n = 1;
		//x..............................................................................
		//>进位	从小往大
		for (size_t i = 序号_第一个n; i < 14; i++)
		{
			进位(vec, i);
		}
		//x..............................................................................
		//>显示	从大往小 \ 是否有数字->补充0->显示数字->右边的N位数 
		for (size_t i = N位个数_有数值; i > 序号_第一个n; i--)
		{
			结果str = 补充0(结果str, vec, i);
			结果str = 返回N位数(结果str, vec, i);
		}
		//补充0 \ 第一个N位数 append0
		结果str = 补充0(结果str, vec, 1);
		//append 第1个N位数
		结果str.append(to_string(vec[1]));
		vecdatap = nullptr; vecp = nullptr;
	}
	///2023年6月12日 03:27:54
	//?编译器错误 \ ;->:了
	auto 进位再返回str(vector<类型>& vec)
	{
		string 结果str;
		进位再返回str(结果str, vec);
		return 结果str;
	}
	//!▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//>N \ 实现
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//>cmd里cout \ 输入一个数字 \ 输出一个数字
	//> 数字-->cout数字
	//把uu转换为 带,的形式
	auto cout计数(int uu) //用class里定义的vector<类型>计数
	{
		计数.assign(2, 0);
		cout数字(计数, uu);
		///2023年6月10日 20:18
		//TODO assign(47 输出的数字位数不够, 像提前结束. \ assign(2 结果错误 \ assign(3 outofrange \ assign(4 一样
	}

	auto cout数字(类型 uu)
	{
		///	2023年6月10日 00:08:24
		//?	函数里定义的vec在函数里的函数里不能修改, 返回vec没用, vec != 返回的vec \
			返回值也有错误, ','左边永远是0 \ 已解决, 有一句被删了
		///	2023年6月10日21:21:05
		//	TODO vector subscript out of range
		vector<类型>  vec;
		初始化();
		vec.assign(2, 0);
		cout数字(vec, uu);
	}
	auto cout数字(vector<类型>& vec, 类型 uu)
	{
		初始化();
		vec[1] = uu;
		进位再cout(vec);
	}
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//>输入一个数字 \ 返回str
	//> 数字-->str
	string 数字str(vector<类型>& vec, 类型 uu)
	{
		string 结果str;
		//=====================================
		vec[1] = uu;
		进位再返回str(结果str, vec);
		return 结果str;
	}
	string 数字str(类型 uu)
	{
		string 结果str;
		vector<类型>  vec;
		初始化();
		vec.assign(2, 0);
		//=====================================
		结果str = 数字str(vec, uu);
		return 结果str;
	}
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//> vector-->cout数字
	auto coutvec(vector<类型>& vec)
	{
		//不初始化
		进位再cout(vec);
	}
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//>输入vector, 返回str
	//> vec-->str
	string 数字str(vector<类型>& vec)
	{
		string 结果str;
		vec.assign(2, 0);
		初始化();
		进位再返回str(结果str, vec);
		return 结果str;
	}
};
//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬




//
//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
//


#endif